// https://github.com/SebiTimeWaster/three-csg
// import * as THREE from "three";
const t=Object.freeze({_CSGDEBUG:!1,defaultResolution2D:32,defaultResolution3D:12,EPS:1e-5,angleEPS:.1,areaEPS:49916708323414084e-28,all:0,top:1,bottom:2,left:3,right:4,front:5,back:6}),e=function(t){return!isNaN(t)||t===1/0||t===-1/0},n=function(t,e){this.normal=t,this.w=e};n.fromVector3Ds=function(t,e,o){let i=e.minus(t).cross(o.minus(t)).unit();return new n(i,i.dot(t))},n.prototype={flipped:function(){return new n(this.normal.negated(),-this.w)},getTag:function(){let t=this.tag;return t||(t=window.getTag(),this.tag=t),t},equals:function(t){return this.normal.equals(t.normal)&&this.w===t.w},splitLineBetweenPoints:function(t,e){let n=e.minus(t),o=(this.w-this.normal.dot(t))/this.normal.dot(n);return isNaN(o)&&(o=0),o>1&&(o=1),o<0&&(o=0),t.plus(n.times(o))},signedDistanceToPoint:function(t){return this.normal.dot(t)-this.w},mirrorPoint:function(t){let e=this.signedDistanceToPoint(t);return t.minus(this.normal.times(2*e))}};let o=function(e,o,i){if(this.vertices=e,this.shared={color:o?o.color:null,getHash:function(){return this.color?this.color.join("/"):this.color},getTag:function(){let t=this.tag;return t||(t=getTag(),this.tag=t),t}},this.plane=arguments.length>=3?i:n.fromVector3Ds(e[0].pos,e[1].pos,e[2].pos),t._CSGDEBUG&&!this.checkIfConvex())throw new Error("Not convex!")};o.prototype={boundingSphere:function(){if(!this.cachedBoundingSphere){let t=this.boundingBox(),e=t[0].plus(t[1]).times(.5),n=t[1].minus(e).length();this.cachedBoundingSphere=[e,n]}return this.cachedBoundingSphere},boundingBox:function(){if(!this.cachedBoundingBox){let t,e,n=this.vertices,o=n.length;t=0===o?new i(0,0,0):n[0].pos,e=t;for(let i=1;i<o;i++){let o=n[i].pos;t=t.min(o),e=e.max(o)}this.cachedBoundingBox=[t,e]}return this.cachedBoundingBox},flipped:function(){let t=this.vertices.map((function(t){return t.flipped()}));return t.reverse(),new o(t,this.shared)}};const i=function(t,n,o){if(3===arguments.length)this._x=parseFloat(t),this._y=parseFloat(n),this._z=parseFloat(o);else if(2===arguments.length)this._x=parseFloat(t),this._y=parseFloat(n),this._z=0;else{var r=!0;if(1===arguments.length)if("object"==typeof t)t instanceof i?(this._x=t._x,this._y=t._y,this._z=t._z):t instanceof Array?t.length<2||t.length>3?r=!1:(this._x=parseFloat(t[0]),this._y=parseFloat(t[1]),3===t.length?this._z=parseFloat(t[2]):this._z=0):"x"in t&&"y"in t?(this._x=parseFloat(t.x),this._y=parseFloat(t.y),this._z="z"in t?parseFloat(t.z):0):"_x"in t&&"_y"in t?(this._x=parseFloat(t._x),this._y=parseFloat(t._y),this._z="_z"in t?parseFloat(t._z):0):r=!1;else{var s=parseFloat(t);this._x=s,this._y=s,this._z=s}else r=!1;if(!r)throw new Error("wrong arguments");e(this._x)&&e(this._y)&&e(this._z)||(r=!1)}};i.Create=function(t,e,n){var o=Object.create(i.prototype);return o._x=t,o._y=e,o._z=n,o},i.prototype={get x(){return this._x},get y(){return this._y},get z(){return this._z},set x(t){throw new Error("Vector is immutable")},set y(t){throw new Error("Vector is immutable")},set z(t){throw new Error("Vector is immutable")},clone:function(){return i.Create(this._x,this._y,this._z)},negated:function(){return i.Create(-this._x,-this._y,-this._z)},abs:function(){return i.Create(Math.abs(this._x),Math.abs(this._y),Math.abs(this._z))},plus:function(t){return i.Create(this._x+t._x,this._y+t._y,this._z+t._z)},minus:function(t){return i.Create(this._x-t._x,this._y-t._y,this._z-t._z)},times:function(t){return i.Create(this._x*t,this._y*t,this._z*t)},dividedBy:function(t){return i.Create(this._x/t,this._y/t,this._z/t)},dot:function(t){return this._x*t._x+this._y*t._y+this._z*t._z},lerp:function(t,e){return this.plus(t.minus(this).times(e))},lengthSquared:function(){return this.dot(this)},length:function(){return Math.sqrt(this.lengthSquared())},unit:function(){return this.dividedBy(this.length())},cross:function(t){return i.Create(this._y*t._z-this._z*t._y,this._z*t._x-this._x*t._z,this._x*t._y-this._y*t._x)},distanceTo:function(t){return this.minus(t).length()},distanceToSquared:function(t){return this.minus(t).lengthSquared()},equals:function(t){return this._x===t._x&&this._y===t._y&&this._z===t._z},multiply4x4:function(t){return t.leftMultiply1x3Vector(this)},randomNonParallelVector:function(){var t=this.abs();return t._x<=t._y&&t._x<=t._z?i.Create(1,0,0):t._y<=t._x&&t._y<=t._z?i.Create(0,1,0):i.Create(0,0,1)},min:function(t){return i.Create(Math.min(this._x,t._x),Math.min(this._y,t._y),Math.min(this._z,t._z))},max:function(t){return i.Create(Math.max(this._x,t._x),Math.max(this._y,t._y),Math.max(this._z,t._z))}};const r=function(t){this.pos=t};r.fromObject=function(t){var e=new i(t.pos);return new r(e)},r.prototype={flipped:function(){return this},getTag:function(){var t=this.tag;return t||(t=window.getTag(),this.tag=t),t},interpolate:function(t,e){var n=this.pos.lerp(t.pos,e);return new r(n)}};let s=function(){this.polygons=[],this.properties=new l};s.prototype={union:function(t){let e,n;for(t instanceof Array?(e=t.slice(0),e.push(this)):e=[this,t],n=1;n<e.length;n+=2)e.push(e[n-1].unionSub(e[n]));return e[n-1]},unionSub:function(t){if(this.mayOverlap(t)){let e=new a(this.polygons),n=new a(t.polygons);e.clipTo(n,!1),n.clipTo(e),n.invert(),n.clipTo(e),n.invert();let o=e.allPolygons().concat(n.allPolygons()),i=this.fromPolygons(o);return i.properties=this.properties._merge(t.properties),i}{let e=this.polygons.concat(t.polygons),n=this.fromPolygons(e);return n.properties=this.properties._merge(t.properties),n}},subtract:function(t){let e;e=t instanceof Array?t:[t];let n=this;for(let t=0;t<e.length;t++){let o=t===e.length-1;n=n.subtractSub(e[t],o,o)}return n},subtractSub:function(t){let e=new a(this.polygons),n=new a(t.polygons);e.invert(),e.clipTo(n),n.clipTo(e,!0),e.addPolygons(n.allPolygons()),e.invert();let o=this.fromPolygons(e.allPolygons());return o.properties=this.properties._merge(t.properties),o},intersect:function(t){let e;e=t instanceof Array?t:[t];let n=this;for(let t=0;t<e.length;t++){let o=t===e.length-1;n=n.intersectSub(e[t],o,o)}return n},intersectSub:function(t){let e=new a(this.polygons),n=new a(t.polygons);e.invert(),n.clipTo(e),n.invert(),e.clipTo(n),n.clipTo(e),e.addPolygons(n.allPolygons()),e.invert();let o=this.fromPolygons(e.allPolygons());return o.properties=this.properties._merge(t.properties),o},fromPolygons:function(t){let e=new s;return e.polygons=t,e},bounds:function(t=this){if(!t.cachedBoundingBox){let e=new i(0,0,0),n=new i(0,0,0),o=t.polygons,r=o.length;for(let t=0;t<r;t++){let i=o[t].boundingBox();0===t?(e=i[0],n=i[1]):(e=e.min(i[0]),n=n.max(i[1]))}t.cachedBoundingBox=[e,n]}return t.cachedBoundingBox},getBounds:function(){return this.bounds()},mayOverlap:function(t){if(0===this.polygons.length||0===t.polygons.length)return!1;{let e=this.bounds(),n=this.bounds(t);return!(e[1].x<n[0].x)&&(!(e[0].x>n[1].x)&&(!(e[1].y<n[0].y)&&(!(e[0].y>n[1].y)&&(!(e[1].z<n[0].z)&&!(e[0].z>n[1].z)))))}},setColor:function(t){this.polygons.forEach(e=>{e.shared.color=t})}};const l=function(){};l.prototype={_transform:function(t){let e=new l;return l.transformObj(this,e,t),e},_merge:function(t){let e=new l;return l.cloneObj(this,e),l.addFrom(e,t),e}},l.transformObj=function(t,e,n){for(let o in t){if("_transform"===o)continue;if("_merge"===o)continue;let i=t[o],r=i;"object"==typeof i&&("transform"in i&&"function"==typeof i.transform?r=i.transform(n):i instanceof Array?(r=[],l.transformObj(i,r,n)):i instanceof l&&(r=new l,l.transformObj(i,r,n))),e[o]=r}},l.cloneObj=function(t,e){for(let n in t){if("_transform"===n)continue;if("_merge"===n)continue;let o=t[n],i=o;if("object"==typeof o)if(o instanceof Array){i=[];for(let t=0;t<o.length;t++)i.push(o[t])}else o instanceof l&&(i=new l,l.cloneObj(o,i));e[n]=i}},l.addFrom=function(t,e){for(let n in e)"_transform"!==n&&"_merge"!==n&&(n in t&&"object"==typeof t[n]&&t[n]instanceof l&&"object"==typeof e[n]&&e[n]instanceof l?l.addFrom(t[n],e[n]):n in t||(t[n]=e[n]))};const h=function(){this.parent=null,this.children=[],this.polygon=null,this.removed=!1};h.prototype={addPolygons:function(t){if(!this.isRootNode())throw new Error("Assertion failed");let e=this;t.map((function(t){e.addChild(t)}))},remove:function(){if(!this.removed){if(this.removed=!0,t._CSGDEBUG){if(this.isRootNode())throw new Error("Assertion failed");if(this.children.length)throw new Error("Assertion failed")}let e=this.parent.children,n=e.indexOf(this);if(n<0)throw new Error("Assertion failed");e.splice(n,1),this.parent.recursivelyInvalidatePolygon()}},isRemoved:function(){return this.removed},isRootNode:function(){return!this.parent},invert:function(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()},getPolygon:function(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon},getPolygons:function(t){let e,n,o,i,r=[this],s=[r];for(e=0;e<s.length;++e)for(r=s[e],n=0,o=r.length;n<o;n++)i=r[n],i.polygon?t.push(i.polygon):s.push(i.children)},splitByPlane:function(t,e,n,o,i){if(this.children.length){let r,s,l,h,a,u=[this.children];for(r=0;r<u.length;r++)for(a=u[r],s=0,l=a.length;s<l;s++)h=a[s],h.children.length?u.push(h.children):h._splitByPlane(t,e,n,o,i)}else this._splitByPlane(t,e,n,o,i)},_splitByPlane:function(e,n,i,s,l){let h=this.polygon;if(h){let a=h.boundingSphere(),u=a[1]+t.EPS,p=e.normal,c=a[0],f=p.dot(c)-e.w;if(f>u)s.push(this);else if(f<-u)l.push(this);else{let a=function(e,n){let i={type:null,front:null,back:null},s=e.normal,l=n.vertices,h=l.length;if(n.plane.equals(e))i.type=0;else{let a=e.w,u=!1,p=!1,c=[],f=-t.EPS;for(let e=0;e<h;e++){let n=s.dot(l[e].pos)-a,o=n<0;c.push(o),n>t.EPS&&(u=!0),n<f&&(p=!0)}if(u||p)if(p)if(u){i.type=4;let s=[],a=[],u=c[0];for(let t=0;t<h;t++){let n=l[t],o=t+1;o>=h&&(o=0);let i=c[o];if(u===i)u?a.push(n):s.push(n);else{let t=n.pos,i=l[o].pos,h=e.splitLineBetweenPoints(t,i),p=new r(h);u?(a.push(n),a.push(p),s.push(p)):(s.push(n),s.push(p),a.push(p))}u=i}let p=t.EPS*t.EPS;if(a.length>=3){let t=a[a.length-1];for(let e=0;e<a.length;e++){let n=a[e];n.pos.distanceToSquared(t.pos)<p&&(a.splice(e,1),e--),t=n}}if(s.length>=3){let t=s[s.length-1];for(let e=0;e<s.length;e++){let n=s[e];n.pos.distanceToSquared(t.pos)<p&&(s.splice(e,1),e--),t=n}}s.length>=3&&(i.front=new o(s,n.shared,n.plane)),a.length>=3&&(i.back=new o(a,n.shared,n.plane))}else i.type=3;else i.type=2;else{let t=s.dot(n.plane.normal);i.type=t>=0?0:1}}return i}(e,h);switch(a.type){case 0:n.push(this);break;case 1:i.push(this);break;case 2:s.push(this);break;case 3:l.push(this);break;case 4:if(a.front){let t=this.addChild(a.front);s.push(t)}if(a.back){let t=this.addChild(a.back);l.push(t)}}}}},addChild:function(t){let e=new h;return e.parent=this,e.polygon=t,this.children.push(e),e},invertSub:function(){let t,e,n,o,i=[this],r=[i];for(t=0;t<r.length;t++)for(i=r[t],e=0,n=i.length;e<n;e++)o=i[e],o.polygon&&(o.polygon=o.polygon.flipped()),r.push(o.children)},recursivelyInvalidatePolygon:function(){let t=this;for(;t.polygon;)t.polygon=null,t.parent&&(t=t.parent)}};const a=function(t){this.polygonTree=new h,this.rootnode=new u(null),t&&this.addPolygons(t)};a.prototype={invert:function(){this.polygonTree.invert(),this.rootnode.invert()},clipTo:function(t,e){e=!!e,this.rootnode.clipTo(t,e)},allPolygons:function(){let t=[];return this.polygonTree.getPolygons(t),t},addPolygons:function(t){let e=this,n=t.map((function(t){return e.polygonTree.addChild(t)}));this.rootnode.addPolygonTreeNodes(n)}};const u=function(t){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=t};u.prototype={invert:function(){let t,e=[this];for(let n=0;n<e.length;n++){t=e[n],t.plane&&(t.plane=t.plane.flipped()),t.front&&e.push(t.front),t.back&&e.push(t.back);let o=t.front;t.front=t.back,t.back=o}},clipPolygons:function(t,e){let n,o={node:this,polygontreenodes:t},i=[];do{if(n=o.node,t=o.polygontreenodes,n.plane){let o=[],r=[],s=e?o:r,l=n.plane,h=t.length;for(let e=0;e<h;e++){let n=t[e];n.isRemoved()||n.splitByPlane(l,s,o,r,o)}n.front&&r.length>0&&i.push({node:n.front,polygontreenodes:r});let a=o.length;if(n.back&&a>0)i.push({node:n.back,polygontreenodes:o});else for(let t=0;t<a;t++)o[t].remove()}o=i.pop()}while(void 0!==o)},clipTo:function(t,e){let n=this,o=[];do{n.polygontreenodes.length>0&&t.rootnode.clipPolygons(n.polygontreenodes,e),n.front&&o.push(n.front),n.back&&o.push(n.back),n=o.pop()}while(void 0!==n)},addPolygonTreeNodes:function(t){let e,n={node:this,polygontreenodes:t},o=[];do{if(e=n.node,0===(t=n.polygontreenodes).length){n=o.pop();continue}let i=e;if(!e.plane){let n=t[0].getPolygon().plane;e.plane=n}let r=[],s=[];for(let e=0,n=t.length;e<n;++e)t[e].splitByPlane(i.plane,i.polygontreenodes,s,r,s);r.length>0&&(e.front||(e.front=new u(e)),o.push({node:e.front,polygontreenodes:r})),s.length>0&&(e.back||(e.back=new u(e)),o.push({node:e.back,polygontreenodes:s})),n=o.pop()}while(void 0!==n)}};const p=(t,e)=>t.map((t,n)=>{const l=(t=>{if(t instanceof s)return t;const e=new s,n=t.index?t.index.array:[],l=t.attributes.position.array,h=(t,e=0)=>l[3*n[t]+e],a=t=>new r(new i(h(t),h(t,1),h(t,2))),u=t=>new r(new i(l[t],l[t+1],l[t+2])),p=t=>[a(t),a(t+1),a(t+2)];if(n.length)for(let t=0;t<n.length;t+=3)e.polygons.push(new o(p(t)));else for(let t=0;t<l.length;t+=9)e.polygons.push(new o([u(t),u(t+3),u(t+6)]));return e.isCanonicalized=!1,e.isRetesselated=!1,e})(t);return e[n]&&l.setColor([e[n].r,e[n].g,e[n].b,1]),l}),c=(t,e,n=[])=>(e=p(e,n)).shift()[t](e);window.staticTag=1,window.getTag=()=>window.staticTag++;const f={BufferGeometry:t=>{if(!(t instanceof s))return t;const e=new THREE.BufferGeometry,n=[],o=[];let i,r=!1;return t.polygons.forEach(t=>{t.shared.color?(i=[t.shared.color[0],t.shared.color[1],t.shared.color[2]],r=!0):i=[1,1,1];for(let e=0;e<t.vertices.length-2;e++){[0,e+1,e+2].forEach(e=>{["x","y","z"].forEach(o=>{n.push(t.vertices[e].pos[o])})});for(let t=0;t<3;t++)o.push(...i)}}),e.setAttribute("position",new THREE.BufferAttribute(new Float32Array(n),3)),r&&e.setAttribute("color",new THREE.BufferAttribute(new Float32Array(o),3)),e.computeVertexNormals(),e},union:c.bind(void 0,"union"),subtract:c.bind(void 0,"subtract"),intersect:c.bind(void 0,"intersect")};window.CSG=f;export default f;